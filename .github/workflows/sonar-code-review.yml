name: Sonar + Gemini Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches: [ main ]

jobs:
  sonar:
    name: SonarQube Scan (action) + Quality Gate check
    runs-on: ubuntu-latest
    environment: stt-environment
    env:
      SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt || true
          pip install pytest pytest-cov || true

      - name: Run tests & produce coverage XML
        env:
          PYTHONPATH: .
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install pytest pytest-cov || true
          mkdir -p coverage-reports
          # generate coverage.xml in coverage-reports/
          pytest -q --disable-warnings --maxfail=1 --cov=. --cov-report=xml:coverage-reports/coverage-python.xml || true
          echo "coverage files:"
          ls -la coverage-reports || true
          echo "coverage xml preview:"
          sed -n '1,160p' coverage-reports/coverage-python.xml || true

      - name: Validate Sonar secrets (fail early)
        run: |
          if [ -z "${SONAR_HOST_URL}" ] || [ -z "${SONAR_TOKEN}" ] || [ -z "${SONAR_PROJECT_KEY}" ]; then
            echo "ERROR: SONAR_HOST_URL, SONAR_TOKEN, SONAR_PROJECT_KEY must be set as secrets/vars."
            exit 1
          fi
          if [[ ! "${SONAR_HOST_URL}" =~ ^https?:// ]]; then
            echo "ERROR: SONAR_HOST_URL must include http:// or https://"
            exit 1
          fi
          echo "Sonar config looks good."

      - name: Run SonarQube Scan (official action)
        uses: sonarsource/sonarqube-scan-action@v3
        env:
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}

      - name: Ensure jq is available (for polling JSON)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Wait for Sonar analysis & check Quality Gate
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        run: |
          set -euo pipefail
          echo "ðŸ”Ž Locating report-task.txt (written by the scanner)..."

          ANALYSIS_ID=""
          CE_URL=""

          # --- Look for report-task.txt in .scannerwork ---
          if [ -f report-task.txt ]; then
            REPORT_FILE="report-task.txt"
          elif [ -f .scannerwork/report-task.txt ]; then
            REPORT_FILE=".scannerwork/report-task.txt"
          else
            REPORT_FILE=$(find . -type f -path "*/.scannerwork/report-task.txt" | head -n1 || true)
          fi

          if [ -n "${REPORT_FILE}" ] && [ -f "${REPORT_FILE}" ]; then
            echo "âœ… Found report-task.txt at: ${REPORT_FILE}"
            cat "${REPORT_FILE}"
            CE_URL=$(grep '^ceTaskUrl=' "${REPORT_FILE}" | cut -d'=' -f2- || true)
            ANALYSIS_ID=$(grep '^analysisId=' "${REPORT_FILE}" | cut -d'=' -f2- || true)
          else
            echo "âš ï¸  report-task.txt NOT found. Falling back to projectKey polling."
          fi

          sonar_api() {
            local path="$1"
            curl -s -u "${SONAR_TOKEN}:" "${SONAR_HOST_URL%/}${path}"
          }

          # Poll CE task
          if [ -n "${CE_URL}" ]; then
            echo "Polling Compute Engine task at: ${CE_URL}"
            for i in $(seq 1 60); do
              TASK_JSON=$(curl -s -u "${SONAR_TOKEN}:" "${CE_URL}")
              status=$(echo "$TASK_JSON" | jq -r '.task.status // empty')
              echo "  attempt $i - task.status=${status}"
              if [ "${status}" = "SUCCESS" ]; then
                ANALYSIS_ID=$(echo "$TASK_JSON" | jq -r '.task.analysisId // empty')
                break
              fi
              if [ "${status}" = "FAILED" ]; then
                echo "âŒ CE task failed. Continuing anyway for testing."
                break
              fi
              sleep 5
            done
          fi

          # Fetch Quality Gate
          echo "Fetching Quality Gate status..."
          if [ -n "${ANALYSIS_ID}" ]; then
            QG_JSON=$(sonar_api "/api/qualitygates/project_status?analysisId=${ANALYSIS_ID}")
          else
            QG_JSON=$(sonar_api "/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}")
          fi
          echo "$QG_JSON" | jq .

          QG_STATUS=$(echo "$QG_JSON" | jq -r '.projectStatus.status // "UNKNOWN"')
          echo "Final Quality Gate status: ${QG_STATUS}"

          if [ "${QG_STATUS}" = "OK" ]; then
            echo "âœ… Quality Gate passed."
          else
            echo "âš ï¸ Quality Gate failed or unknown (status=${QG_STATUS})."
            echo "  Ignoring failure for CI pass (testing mode)."
          fi

          # Always exit 0 to not break workflow
          exit 0

      - name: Fetch SonarQube PR analysis & Post Sonar summary as PR comment
        if: ${{ github.event.pull_request != null }}
        env:
          BASE: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          BASE="${BASE%/}"
          echo "Fetching Sonar data for project=${SONAR_PROJECT_KEY}, PR=${PR_NUMBER}"

          mkdir -p sonar_data

          # Fetch project quality gate
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" \
            -o sonar_data/qg.json || echo "{}" > sonar_data/qg.json

          # Fetch key measures
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/measures/component?component=${SONAR_PROJECT_KEY}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density" \
            -o sonar_data/measures.json || echo "{}" > sonar_data/measures.json

          # 1) Try PR-scoped issues first (most relevant for PR reviews)
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/issues/search?componentKeys=${SONAR_PROJECT_KEY}&pullRequest=${PR_NUMBER}&ps=20" \
            -o sonar_data/issues_pr.json || echo "{}" > sonar_data/issues_pr.json

          # 2) If PR-scoped returned none, fallback to component-wide issues (wider scan)
          HAS_PR_ISSUES=$(jq -r '(.issues | length) // 0' sonar_data/issues_pr.json 2>/dev/null || echo "0")
          if [ "${HAS_PR_ISSUES}" -eq 0 ]; then
            echo "No PR-scoped issues found; fetching component-wide issues as fallback..."
            curl -s -u "${SONAR_TOKEN}:" \
              "${BASE}/api/issues/search?componentKeys=${SONAR_PROJECT_KEY}&ps=50" \
              -o sonar_data/issues_component.json || echo "{}" > sonar_data/issues_component.json
            ISSUES_FILE="sonar_data/issues_component.json"
          else
            ISSUES_FILE="sonar_data/issues_pr.json"
          fi

          echo "## ðŸ›°ï¸ SonarQube Summary for PR #${PR_NUMBER}" > sonar_comment.md
          echo "" >> sonar_comment.md

          # --- QUALITY GATE ---
          echo "### ðŸ§­ Quality Gate" >> sonar_comment.md
          if jq -e '.projectStatus' sonar_data/qg.json >/dev/null 2>&1; then
            jq -r '.projectStatus | "- **Status:** " + (.status // "UNKNOWN")' sonar_data/qg.json >> sonar_comment.md
            if jq -e '.projectStatus.conditions' sonar_data/qg.json >/dev/null 2>&1; then
              echo "" >> sonar_comment.md
              echo "- **Conditions:**" >> sonar_comment.md
              jq -r '.projectStatus.conditions[] | "  - " + (.metricKey // "unknown") + ": " + (.status // "UNKNOWN") + " (actual: " + ((.actual.value // "null")|tostring) + ")"' sonar_data/qg.json >> sonar_comment.md
            fi
          else
            echo "- (Quality gate unavailable)" >> sonar_comment.md
          fi
          echo "" >> sonar_comment.md

          # --- KEY METRICS ---
          echo "### ðŸ“Š Key Metrics" >> sonar_comment.md
          if jq -e '.component.measures' sonar_data/measures.json >/dev/null 2>&1; then
            jq -r '.component.measures[] | "- " + .metric + ": " + (.value // "null")' sonar_data/measures.json >> sonar_comment.md
          else
            echo "- (metrics unavailable)" >> sonar_comment.md
          fi
          echo "" >> sonar_comment.md

          # --- TOP ISSUES ---
          echo "### âš ï¸ Top Sonar Issues" >> sonar_comment.md

          if jq -e '.issues' "${ISSUES_FILE}" >/dev/null 2>&1; then
            COUNT=$(jq -r '(.issues | length) // 0' "${ISSUES_FILE}")
            if [ "$COUNT" -eq 0 ]; then
              echo "_No Sonar issues returned for this query._" >> sonar_comment.md
            else
              echo "" >> sonar_comment.md
              echo "| Severity | Rule | Location | Message |" >> sonar_comment.md
              echo "|---|---|---|---|" >> sonar_comment.md
              # Sort by severity (string sort) then show first 20 results - truncate messages to 300 chars
              jq -r '.issues | sort_by(.severity) | reverse | .[0:20] | .[] |
                ("| " + (.severity // "INFO") +
                 " | " + (.rule // "unknown") +
                 " | " + ((.component // "unknown") + (if .line then ":" + (.line|tostring) else "" end)) +
                 " | " + ((.message // "") | gsub("\n"; " ") | .[0:300]) + " |")' "${ISSUES_FILE}" >> sonar_comment.md
            fi
          else
            echo "_Failed to parse issues JSON or none returned._" >> sonar_comment.md
          fi
          echo "" >> sonar_comment.md

          # --- SONAR DASHBOARD LINK ---
          if grep -q '^dashboardUrl=' .scannerwork*/report-task.txt 2>/dev/null; then
            DASH=$(grep '^dashboardUrl=' .scannerwork*/report-task.txt 2>/dev/null | cut -d'=' -f2- | head -n1)
            echo "[ðŸ”— View full results in SonarQube Dashboard](${DASH})" >> sonar_comment.md
          fi

          echo "=== sonar_comment.md preview ==="
          sed -n '1,200p' sonar_comment.md || true

          # --- POST COMMENT TO GITHUB ---
          PAYLOAD=$(jq -Rs --arg body "$(cat sonar_comment.md)" '{body: $body}')
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments"
          curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$PAYLOAD" "$API" \
            && echo "âœ… Posted Sonar summary comment to PR #${PR_NUMBER}."

  gemini-review:
    name: Gemini AI Code Review
    needs: sonar
    # run only when sonar job succeeded
    if: ${{ needs.sonar.result == 'success' }}
    runs-on: ubuntu-latest
    environment: stt-environment
    env:
      SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure PR context exists
        id: pr_check
        run: |
          if [ -z "${{ github.event.pull_request.number }}" ]; then
            echo "No pull_request context found; exiting."
            echo "has_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "has_pr=true" >> $GITHUB_OUTPUT

      - name: Get Pull Request Diff
        if: ${{ steps.pr_check.outputs.has_pr == 'true' }}
        id: get_diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          echo "Fetching PR diff for PR #${PR_NUM}"
          gh api repos/${{ github.repository }}/pulls/${PR_NUM} \
            --header "Accept: application/vnd.github.v3.diff" > pr_diff.txt
          echo "Saved pr_diff.txt (size: $(wc -c < pr_diff.txt) bytes)"

      - name: Fetch SonarQube PR analysis (if configured)
        if: ${{ env.SONAR_HOST_URL && env.SONAR_TOKEN && env.SONAR_PROJECT_KEY && steps.pr_check.outputs.has_pr == 'true' }}
        env:
          BASE: ${{ env.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ env.SONAR_PROJECT_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -e
          BASE="${BASE%/}"
          echo "Fetching Sonar data for project=${SONAR_PROJECT_KEY}, PR=${PR_NUMBER}"

          # Issues for this PR
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/issues/search?componentKeys=${SONAR_PROJECT_KEY}&pullRequest=${PR_NUMBER}&ps=500" \
            -o sonar_issues.json || echo "{}" > sonar_issues.json

          # Quality gate status
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" \
            -o sonar_qg.json || echo "{}" > sonar_qg.json

          # Key measures
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/measures/component?component=${SONAR_PROJECT_KEY}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density" \
            -o sonar_measures.json || echo "{}" > sonar_measures.json

          # Build human-readable summary
          echo "### SonarQube Analysis Summary for PR #${PR_NUMBER}" > sonar_summary.txt
          echo "" >> sonar_summary.txt

          echo "Quality Gate:" >> sonar_summary.txt
          if jq -e '.projectStatus' sonar_qg.json >/dev/null 2>&1; then
            jq -r '.projectStatus | "  status: " + (.status // "UNKNOWN")' sonar_qg.json >> sonar_summary.txt
          else
            echo "  Unable to fetch quality gate" >> sonar_summary.txt
          fi
          echo "" >> sonar_summary.txt

          echo "Key metrics:" >> sonar_summary.txt
          if jq -e '.component.measures' sonar_measures.json >/dev/null 2>&1; then
            jq -r '.component.measures[] | "  - " + .metric + ": " + (.value // "null")' sonar_measures.json >> sonar_summary.txt
          else
            echo "  Unable to fetch measures" >> sonar_summary.txt
          fi
          echo "" >> sonar_summary.txt

          echo "Top Sonar issues (up to 20):" >> sonar_summary.txt
          if jq -e '.issues' sonar_issues.json >/dev/null 2>&1; then
            jq -r '.issues | sort_by(.severity) | reverse | .[] | ("  - [" + (.severity // "INFO") + "] " + (.rule // "unknown") + " / " + (.component // "unknown") + (if .line then ":" + (.line|tostring) else "" end) + " â€” " + (.message|gsub("\n"; " ")))' sonar_issues.json | sed -n '1,20p' >> sonar_summary.txt
          else
            echo "  No issues found or failed to parse" >> sonar_summary.txt
          fi
          echo "" >> sonar_summary.txt

          echo "Issue counts by severity:" >> sonar_summary.txt
          if jq -e '.issues' sonar_issues.json >/dev/null 2>&1; then
            jq -r '.issues | group_by(.severity) | map({(.[0].severity): length}) | add | to_entries[] | "  - " + .key + ": " + (.value|tostring)' sonar_issues.json >> sonar_summary.txt 2>/dev/null || echo "  none" >> sonar_summary.txt
          else
            echo "  none" >> sonar_summary.txt
          fi

          ls -l sonar_*.json sonar_summary.txt || true
          echo "âœ… Sonar summary prepared."

      - name: Combine Prompt, Sonar summary and Diff
        run: |
          # Build the prompt file
          cat .gemini/prompt.txt > full_prompt.txt || echo "Base prompt not found" > full_prompt.txt
          echo -e "\n\n## ðŸ”Ž SonarQube Summary\n\n" >> full_prompt.txt
          if [ -f sonar_summary.txt ]; then
            cat sonar_summary.txt >> full_prompt.txt
          else
            echo "No Sonar summary available." >> full_prompt.txt
          fi
          echo -e "\n\n## ðŸ”„ Full Diff Below\n\n" >> full_prompt.txt
          if [ -f pr_diff.txt ]; then
            cat pr_diff.txt >> full_prompt.txt
          else
            echo "No PR diff available." >> full_prompt.txt
          fi
          echo "âœ… Full prompt ready at full_prompt.txt"

      - name: Load Prompt from File
        id: load_prompt
        run: |
          PROMPT_CONTENT=$(cat full_prompt.txt || echo "No prompt file")
          echo "prompt_text<<EOF" >> $GITHUB_OUTPUT
          echo "$PROMPT_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run Gemini Code Review
        id: run_gemini
        uses: google-github-actions/run-gemini-cli@v0.1.14
        with:
          gemini_model: "gemini-2.5-pro"
          gemini_api_key: ${{ env.GEMINI_API_KEY }}
          use_vertex_ai: false
          use_gemini_code_assist: false
          prompt: ${{ steps.load_prompt.outputs.prompt_text }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Save Gemini Output (robust)
        id: save_gemini
        run: |
          echo "ðŸ“„ Saving Gemini output..."
          candidates=(
            "gemini-artifacts/stdout.log"
            "stdout.log"
            "gemini-artifacts/stdout.txt"
            "gemini-output.txt"
          )
          found=""
          for f in "${candidates[@]}"; do
            if [ -f "$f" ]; then
              found="$f"
              break
            fi
          done
          if [ -z "$found" ]; then
            found=$(find . -type f -name 'stdout.log' -print -quit || true)
          fi
          if [ -n "$found" ]; then
            echo "Found Gemini output at: $found"
            tail -n 2000 "$found" > gemini_output.txt || cp "$found" gemini_output.txt
          else
            echo "No Gemini output found. Writing fallback message."
            echo "Gemini action produced no output file. Check run_gemini logs." > gemini_output.txt
          fi
          echo "=== gemini_output.txt preview ==="
          sed -n '1,200p' gemini_output.txt || true

      - name: Post Gemini Review Comments (one comment per heading/table)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // ----------------------------
            // Robustly determine PR/issue number
            // ----------------------------
            const issueNumber = (context && context.issue && context.issue.number)
              ? context.issue.number
              : (github && github.context && github.context.payload && github.context.payload.pull_request && github.context.payload.pull_request.number)
                ? github.context.payload.pull_request.number
                : (process.env.PR_NUMBER ? parseInt(process.env.PR_NUMBER, 10) : null);

            if (!issueNumber) {
              console.log("No PR/issue context found â€” skipping Gemini comment posting.");
              return;
            }

            // ----------------------------
            // Find gemini output file (mirrors your shell logic)
            // ----------------------------
            function findGeminiFile() {
              const candidates = [
                'gemini_output.txt',
                'gemini-output.txt',
                'gemini-artifacts/stdout.log',
                'stdout.log',
                'gemini-artifacts/stdout.txt'
              ];
              for (const c of candidates) {
                try {
                  if (fs.existsSync(c) && fs.statSync(c).isFile()) return c;
                } catch (e) {}
              }
              // shallow search (top-level + one-level) for files named stdout.log
              try {
                const entries = fs.readdirSync('.');
                for (const e of entries) {
                  const maybe = `./${e}`;
                  if (fs.existsSync(maybe) && fs.statSync(maybe).isFile() && e.toLowerCase().includes('stdout.log')) return maybe;
                  if (fs.existsSync(maybe) && fs.statSync(maybe).isDirectory()) {
                    const sub = fs.readdirSync(maybe);
                    for (const s of sub) {
                      if (s.toLowerCase().includes('stdout.log')) {
                        const candidate = `${maybe}/${s}`;
                        if (fs.existsSync(candidate) && fs.statSync(candidate).isFile()) return candidate;
                      }
                    }
                  }
                }
              } catch (e) {
                // ignore
              }
              return null;
            }

            // ----------------------------
            // Read raw gemini output with fallbacks
            // ----------------------------
            let raw;
            const found = findGeminiFile();
            if (!found) {
              raw = "Gemini action produced no output file. Check run_gemini logs.";
            } else {
              try {
                raw = fs.readFileSync(found, 'utf8');
                if (!raw || !raw.trim()) raw = "Gemini ran but produced empty output.";
              } catch (e) {
                raw = `Failed to read ${found}: ${e.toString()}`;
              }
            }

            // ----------------------------
            // Basic sanitization while preserving markdown tables and headings
            // - normalize newlines
            // - unwrap outer fenced block if present
            // - remove <summary>/<details> wrappers (keep inner content)
            // - remove stray self-closing tags
            // - remove small uniform indent
            // - collapse excessive blank lines
            // ----------------------------
            let s = String(raw).replace(/\r\n/g, '\n');

            // unwrap outer fence if entire output is fenced
            if (/^\s*```/.test(s) && /```\s*$/.test(s)) {
              s = s.replace(/^\s*```(?:\w+)?\n?/, '').replace(/\n?```\s*$/, '').trim();
            }

            // remove wrapper-like tags but keep content
            s = s.replace(/<\s*(summary|SUMMARY|details|DETAILS)[^>]*>([\s\S]*?)<\s*\/\s*\1\s*>/g, '$2');

            // remove self-closing tags (non-essential)
            s = s.replace(/<[^>]+\/>/g, '');

            // detect small uniform indent and remove it (helps keep markdown aligned)
            const linesInitial = s.split('\n');
            let minIndent = Infinity;
            for (const l of linesInitial) {
              if (l.trim() === '') continue;
              const m = l.match(/^(\s*)/);
              if (m) minIndent = Math.min(minIndent, m[1].length);
            }
            if (minIndent === Infinity) minIndent = 0;
            if (minIndent > 0 && minIndent <= 8) {
              s = linesInitial.map(l => l.startsWith(' '.repeat(minIndent)) ? l.slice(minIndent) : l).join('\n');
            }

            s = s.replace(/\n{3,}/g, '\n\n').trim();

            // ----------------------------
            // Parser: split into sections by headings (## / ###)
            // Requirements:
            // - heading line like "### 1. Scope" or "## Review Findings Summary" starts a section
            // - section includes everything up to the next heading
            // - do NOT split inside fenced code blocks (```), or inside tables â€” we collect until table end
            // - support explicit <SUMMARY> ... </SUMMARY> as its own section
            // ----------------------------
            function splitIntoHeadingSections(text) {
              const lines = text.split('\n');
              const sections = [];
              let current = { title: null, content: [] };

              const headingRe = /^\s*#{2,3}\s*(?:\d+\.)?\s*(.+?)\s*$/; // capture heading text after ##/###
              const summaryStartRe = /^\s*<\s*SUMMARY\s*>\s*$/i;
              const summaryEndRe = /^\s*<\s*\/\s*SUMMARY\s*>\s*$/i;

              let inSummaryBlock = false;
              const summaryBuf = [];

              // track fenced codeblock state â€” don't treat heading-like lines inside a fenced block as headings
              let inFence = false;
              let fenceMarker = null; // ``` or ~~~

              for (let i = 0; i < lines.length; i++) {
                const rawLine = lines[i];

                // fence detection (``` or ~~~), support optional language on opening fence
                const fenceMatch = rawLine.match(/^(\s*)(```|~~~)/);
                if (fenceMatch) {
                  const marker = fenceMatch[2];
                  if (!inFence) {
                    inFence = true;
                    fenceMarker = marker;
                  } else if (marker === fenceMarker) {
                    inFence = false;
                    fenceMarker = null;
                  }
                  // always include fence lines in current content
                  if (inSummaryBlock) summaryBuf.push(rawLine); else current.content.push(rawLine);
                  continue;
                }

                // handle explicit <SUMMARY> blocks (these are not fenced code)
                if (summaryStartRe.test(rawLine) && !inFence) {
                  inSummaryBlock = true;
                  continue;
                }
                if (summaryEndRe.test(rawLine) && inSummaryBlock && !inFence) {
                  inSummaryBlock = false;
                  const content = summaryBuf.join('\n').trim();
                  if (content) sections.push({ title: 'Review Summary', content });
                  summaryBuf.length = 0;
                  continue;
                }
                if (inSummaryBlock) {
                  summaryBuf.push(rawLine);
                  continue;
                }

                // If inside fenced code, do not attempt to detect headings â€” just collect
                if (inFence) {
                  current.content.push(rawLine);
                  continue;
                }

                // Heading detection (only when NOT in fence or summary block)
                const h = rawLine.match(headingRe);
                if (h) {
                  const title = h[1].trim();
                  // push previous section (if any)
                  if ((current.title && current.title.trim() !== '') || (current.content && current.content.join('\n').trim() !== '')) {
                    sections.push({ title: current.title || 'Intro', content: current.content.join('\n').trim() });
                  }
                  // start new section with this heading as the title (we won't include the heading line in content)
                  current = { title: title, content: [] };
                  continue; // skip adding the heading itself into content
                }

                // Not a heading line: add to current content
                current.content.push(rawLine);
              }

              // push last
              if ((current.title && current.title.trim() !== '') || (current.content && current.content.join('\n').trim() !== '')) {
                sections.push({ title: current.title || 'Misc', content: current.content.join('\n').trim() });
              }

              return sections;
            }

            const sections = splitIntoHeadingSections(s).filter(sec => sec && (sec.title || (sec.content && sec.content.trim() !== '')));

            // If nothing parsed, fallback to one giant section
            const finalSections = (sections && sections.length > 0) ? sections : [{ title: 'Gemini Output', content: s || '(empty)' }];

            // ----------------------------
            // Helper to ensure we don't split a markdown table across comments:
            // If a section ends in the middle of a table (i.e., last non-empty lines are table rows starting with '|'),
            // we will attempt to extend the section until the table ends (lines that look like table rows or alignment rows).
            // (This is defensive â€” our split logic already takes whole section until next heading; this ensures mid-section tables
            //  that may be followed by a heading line accidentally recognized inside table aren't cut.)
            // ----------------------------
            function extendSectionToCompleteTable(sectionContent, followingLines) {
              // If last non-empty line of section is not a table row, nothing to do.
              const lines = sectionContent.split('\n');
              let ptr = lines.length - 1;
              while (ptr >= 0 && lines[ptr].trim() === '') ptr--;
              if (ptr < 0) return { content: sectionContent, consumed: 0 };

              const lastLine = lines[ptr] || '';
              // table row detection: starts with '|' OR contains '| ---' separator line
              const isTableRow = /^\s*\|/.test(lastLine) || /^\s*:?-{2,}\s*\|/.test(lastLine);
              if (!isTableRow) return { content: sectionContent, consumed: 0 };

              // We are at table end? If the next lines (from followingLines) continue table rows, pull them in.
              let consumed = 0;
              const added = [];
              for (let i = 0; i < followingLines.length; i++) {
                const ln = followingLines[i];
                // If blank line occurs after table and then a heading, stop. We treat lines that start with '|' as table row
                if (/^\s*\|/.test(ln) || /^\s*$/.test(ln) || /^\s*\|?-{2,}/.test(ln)) {
                  // include it as part of table block (blank lines allowed)
                  added.push(ln);
                  consumed++;
                } else {
                  // non-table content: stop extending
                  break;
                }
              }
              if (consumed > 0) {
                const newContent = sectionContent + '\n' + added.join('\n');
                return { content: newContent.trim(), consumed };
              }
              return { content: sectionContent, consumed: 0 };
            }

            // ----------------------------
            // Build comment bodies (one per section)
            // - ensure the comment ends at logical boundaries (table end or paragraph end)
            // - truncate large sections safely, preferring to cut after a blank line or table boundary
            // ----------------------------
            const GH_MAX = 64000;
            const comments = [];

            for (let i = 0; i < finalSections.length; i++) {
              const sec = finalSections[i];
              let title = sec.title ? String(sec.title).replace(/^\d+\.*\s*/, '').trim() : `Section ${i+1}`;
              let content = sec.content ? String(sec.content).trim() : '';

              // If the section is empty, add a placeholder table/row (so each heading still has a comment)
              if (!content) {
                content = "_(no content for this heading)_\n\n| (none) | | | |";
              }

              // Build initial body
              let body = `### ðŸ¤– Gemini Code Review â€” ${title}\n\n${content}`;

              // If body is too large, try to find a safe split point: prefer last double-newline, last table end, or truncate
              if (body.length > GH_MAX) {
                // prefer to split at last blank-line + small neighborhood
                const candidates = [];

                // 1) last double newline within limit
                const snippet = body.slice(0, GH_MAX - 200); // leave headroom
                const lastDouble = snippet.lastIndexOf('\n\n');
                if (lastDouble > Math.floor(snippet.length * 0.2)) candidates.push(lastDouble);

                // 2) last table boundary (closing row) within snippet (find last line starting with '|')
                const lastPipe = snippet.lastIndexOf('\n|');
                if (lastPipe > 0) candidates.push(lastPipe);

                // choose best (largest safe)
                const chosen = (candidates.length > 0) ? Math.max(...candidates) : GH_MAX - 300;
                body = body.slice(0, chosen) + `\n\n(Truncated â€” remainder available in gemini_output.txt or logs.)`;
              }

              comments.push(body);
            }

            // ----------------------------
            // Post comments sequentially
            // ----------------------------
            for (let idx = 0; idx < comments.length; idx++) {
              const c = comments[idx];
              const footer = `\n\n---\n*Comment ${idx+1} of ${comments.length} â€” generated from gemini_output.txt*`;
              const finalBody = c + footer;
              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber, 10),
                  body: finalBody
                });
                // note: no artificial sleeps here; GitHub REST allows multiple comments in sequence.
              } catch (err) {
                // safe error reporting as a comment
                const errMsg = (err && err.toString) ? err.toString() : String(err);
                const errBody = `### âš ï¸ Gemini Review â€” Posting Failed\n\nFailed to post comment ${idx+1} (${idx+1}/${comments.length}):\n\`\`\`\n${errMsg}\n\`\`\`\n\nPartial results may have been posted.`;
                try {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parseInt(issueNumber, 10),
                    body: errBody
                  });
                } catch (postErr) {
                  console.error("Also failed to post error comment:", postErr);
                }
                throw err;
              }
            }

            console.log(`Posted ${comments.length} Gemini comment(s) to PR/issue #${issueNumber}.`);